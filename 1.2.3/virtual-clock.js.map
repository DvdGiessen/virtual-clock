{"version":3,"sources":["../src/virtual-clock.js"],"names":["VirtualClock","_now","performance","now","bind","process","hrtime","Date","_previousTime","_previousNow","_rate","_running","_minimum","Infinity","_maximum","_loop","_eventListeners","Map","_timeListeners","_nullTimeoutID","setTimeout","prop","startsWith","Object","defineProperty","enumerable","getOwnPropertyNames","prototype","descriptor","getOwnPropertyDescriptor","value","_recalculateTimeListeners","trigger","time","event","callback","listeners","get","push","set","i","indexOf","splice","Error","args","slice","forEach","listener","apply","keys","_recalculateTimeListener","listenerData","timeoutID","lastCalled","once","clearTimeout","currentTime","until","Math","abs","ceil","newTimeoutID","untilRecalculate","min","call","NaN","isNaN","hasRemoved","listenerTime","listenerCallback","max","running","start","stop","rate","minimum","previousTime","maximum","loop"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;MACqBA,Y;AAajB;AACJ;AACA;AACI,4BAAoB;AAAA;;AAChB;AACA,WAAKC,IAAL,GACK,OAAOC,WAAP,KAAuB,WAAvB;AAAsC;AAAwBA,MAAAA,WAAW,CAACC,GAAZ,CAAgBC,IAAhB,CAAqBF,WAArB,CAA/D,IACC,OAAOG,OAAP,KAAmB,WAAnB;AAAkC;AAAoBA,MAAAA,OAAO,CAACC,MAA9D,IAAyE,YAAc;AACpF,YAAMH,GAAqB,GAAGE,OAAO,CAACC,MAAR,EAA9B;AACA,eAAOH,GAAG,CAAC,CAAD,CAAH,GAAS,GAAT,GAAeA,GAAG,CAAC,CAAD,CAAH,GAAS,GAA/B;AACH,OAJD,IAKAI,IAAI,CAACJ,GANT,CAFgB,CAUhB;;;AACA,WAAKK,aAAL,GAAqB,CAArB;AACA,WAAKC,YAAL,GAAoB,KAAKR,IAAL,EAApB,CAZgB,CAchB;;AACA,WAAKS,KAAL,GAAa,GAAb;AACA,WAAKC,QAAL,GAAgB,KAAhB,CAhBgB,CAkBhB;;AACA,WAAKC,QAAL,GAAgB,CAACC,QAAjB;AACA,WAAKC,QAAL,GAAgBD,QAAhB;AACA,WAAKE,KAAL,GAAa,KAAb,CArBgB,CAuBhB;;AACA,WAAKC,eAAL,GAAuB,IAAIC,GAAJ,EAAvB;AACA,WAAKC,cAAL,GAAsB,IAAID,GAAJ,EAAtB,CAzBgB,CA2BhB;;AACA,WAAKE,cAAL,GAAsBC,UAAU,CAAC,YAAM,CAAE,CAAT,EAAW,CAAX,CAAhC,CA5BgB,CA8BhB;;AACA,WAAK,IAAMC,IAAX,IAAmB,IAAnB,EAAyB;AACrB,YAAIA,IAAI,CAACC,UAAL,CAAgB,GAAhB,CAAJ,EAA0B;AACtBC,UAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4BH,IAA5B,EAAkC;AAAEI,YAAAA,UAAU,EAAE;AAAd,WAAlC;AACH;AACJ,OAnCe,CAqChB;;;AArCgB,iDAsCGF,MAAM,CAACG,mBAAP,CAA2B1B,YAAY,CAAC2B,SAAxC,CAtCH;AAAA;;AAAA;AAsChB,4DAAuE;AAAA,cAA5DN,KAA4D;AACnE,cAAMO,UAAU,GAAGL,MAAM,CAACM,wBAAP,CAAgC7B,YAAY,CAAC2B,SAA7C,EAAwDN,KAAxD,CAAnB;;AACA,cAAIO,UAAU,IAAI,WAAWA,UAAzB,IAAuC,OAAOA,UAAU,CAACE,KAAlB,KAA4B,UAAvE,EAAmF;AAC/EP,YAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4BH,KAA5B,EAAkC;AAAES,cAAAA,KAAK,EAAEF,UAAU,CAACE,KAAX,CAAiB1B,IAAjB,CAAsB,IAAtB;AAAT,aAAlC;AACH;AACJ;AA3Ce;AAAA;AAAA;AAAA;AAAA;AA4CnB,K,CAED;;AACA;AACJ;AACA;;;;;8BAC0B;AAClB;AACA,YAAI,CAAC,KAAKO,QAAV,EAAoB;AAChB,eAAKF,YAAL,GAAoB,KAAKR,IAAL,EAApB;AACA,eAAKU,QAAL,GAAgB,IAAhB;;AACA,eAAKoB,yBAAL,GAHgB,CAKhB;;;AACA,eAAKC,OAAL,CAAa,OAAb;AACA,eAAKA,OAAL,CAAa,YAAb;AACH,SAViB,CAYlB;;;AACA,eAAO,IAAP;AACH;AAED;AACJ;AACA;;;;6BACyB;AACjB;AACA,YAAI,KAAKrB,QAAT,EAAmB;AACf,eAAKH,aAAL,GAAqB,KAAKyB,IAA1B;AACA,eAAKtB,QAAL,GAAgB,KAAhB;;AACA,eAAKoB,yBAAL,GAHe,CAKf;;;AACA,eAAKC,OAAL,CAAa,MAAb;AACA,eAAKA,OAAL,CAAa,YAAb;AACH,SAVgB,CAYjB;;;AACA,eAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;;yBACOE,K,EAAeC,Q,EAAqC;AACnD;AACA,YAAMC,SAAS,GAAG,KAAKpB,eAAL,CAAqBqB,GAArB,CAAyBH,KAAzB,CAAlB;;AACA,YAAIE,SAAJ,EAAe;AACXA,UAAAA,SAAS,CAACE,IAAV,CAAeH,QAAf;AACH,SAFD,MAEO;AACH,eAAKnB,eAAL,CAAqBuB,GAArB,CAAyBL,KAAzB,EAAgC,CAACC,QAAD,CAAhC;AACH,SAPkD,CASnD;;;AACA,eAAO,IAAP;AACH;AAED;AACJ;AACA;;;;0BACQD,K,EAAeC,Q,EAAqC;AACpD;AACA,YAAMC,SAAS,GAAG,KAAKpB,eAAL,CAAqBqB,GAArB,CAAyBH,KAAzB,CAAlB;;AACA,YAAIE,SAAJ,EAAe;AACX,cAAMI,CAAC,GAAGJ,SAAS,CAACK,OAAV,CAAkBN,QAAlB,CAAV;;AACA,cAAIK,CAAC,IAAI,CAAT,EAAY;AACR;AACAJ,YAAAA,SAAS,CAACM,MAAV,CAAiBF,CAAjB,EAAoB,CAApB,EAFQ,CAIR;;AACA,mBAAO,IAAP;AACH;AACJ,SAZmD,CAcpD;;;AACA,cAAM,IAAIG,KAAJ,CAAU,0BAAV,CAAN;AACH;AAED;AACJ;AACA;;;;8BACYT,K,EAA+C;AAAA;;AAAA,0CAA7BU,IAA6B;AAA7BA,UAAAA,IAA6B;AAAA;;AACnD,YAAMR,SAAS,GAAG,KAAKpB,eAAL,CAAqBqB,GAArB,CAAyBH,KAAzB,CAAlB;;AACA,YAAIE,SAAJ,EAAe;AACXA,UAAAA,SAAS,CAACS,KAAV,CAAgB,CAAhB,EAAmBC,OAAnB,CAA2B,UAAAC,QAAQ,EAAI;AACnCA,YAAAA,QAAQ,CAACC,KAAT,CAAe,KAAf,EAAqBJ,IAArB;AACH,WAFD;AAGH,SANkD,CAQnD;;;AACA,eAAO,IAAP;AACH;AAED;AACJ;AACA;;;;kDACsC;AAAA,oDACP,KAAK1B,cAAL,CAAoB+B,IAApB,EADO;AAAA;;AAAA;AAC9B,iEAAmD;AAAA,gBAAxCF,QAAwC;;AAC/C,iBAAKG,wBAAL,CAA8BH,QAA9B;AACH;AAH6B;AAAA;AAAA;AAAA;AAAA;AAIjC;AAED;AACJ;AACA;;;;+CAC6BA,Q,EAAuC;AAAA;;AAC5D;AACA,YAAMI,YAAY,GAAG,KAAKjC,cAAL,CAAoBmB,GAApB,CAAwBU,QAAxB,CAArB;;AACA,YAAII,YAAJ,EAAkB;AAAA,yCACWJ,QADX;AAAA,cACPd,IADO;AAAA,cACDE,QADC;;AAAA,6CAEwBgB,YAFxB;AAAA,cAEPC,SAFO;AAAA,cAEIC,UAFJ;AAAA,cAEgBC,IAFhB,qBAId;;;AACAC,UAAAA,YAAY,CAACH,SAAD,CAAZ,CALc,CAOd;;AACA,cAAI,KAAKzC,QAAL,IAAiB,KAAKD,KAAL,KAAe,CAAhC,IAAqCuB,IAAI,IAAI,KAAKrB,QAAlD,IAA8DqB,IAAI,IAAI,KAAKnB,QAA/E,EAAyF;AACrF;AACA,gBAAM0C,WAAW,GAAG,KAAKvB,IAAzB,CAFqF,CAIrF;;AACA,gBAAIuB,WAAW,KAAKH,UAApB,EAAgC;AAC5B;AACA,kBAAI,KAAKtC,KAAL,IAAeyC,WAAW,KAAK,KAAK5C,QAArB,IAAiC4C,WAAW,KAAK,KAAK1C,QAAzE,EAAoF;AAChF;AACA,qBAAKI,cAAL,CAAoBqB,GAApB,CAAwBQ,QAAxB,EAAkC,CAAC3B,UAAU,CAAC,YAAM;AAChD,kBAAA,MAAI,CAAC8B,wBAAL,CAA8BH,QAA9B;AACH,iBAF4C,EAE1C,CAF0C,CAAX,EAE3BM,UAF2B,EAEfC,IAFe,CAAlC;AAGH;AACJ,aARD,MAQO;AACH;AACA,kBAAIG,KAAJ,CAFG,CAIH;;AACA,kBAAI,KAAK/C,KAAL,GAAa,CAAjB,EAAoB;AAChB+C,gBAAAA,KAAK,GAAGxB,IAAI,GAAGuB,WAAf;AACH,eAFD,MAEO;AACHC,gBAAAA,KAAK,GAAGD,WAAW,GAAGvB,IAAtB;AACH,eATE,CAWH;;;AACA,kBAAIwB,KAAK,IAAI,CAAT,IAAe,KAAK1C,KAAL,IAAc,KAAKH,QAAL,GAAgB,CAACC,QAA/B,IAA2C,KAAKC,QAAL,GAAgBD,QAA9E,EAAyF;AACrF;AACA,oBAAI4C,KAAK,GAAG,CAAZ,EAAe;AACXA,kBAAAA,KAAK,IAAI,KAAK3C,QAAL,GAAgB,KAAKF,QAA9B;AACH,iBAJoF,CAMrF;;;AACA6C,gBAAAA,KAAK,IAAI,IAAIC,IAAI,CAACC,GAAL,CAAS,KAAKjD,KAAd,CAAb,CAPqF,CASrF;;AACA+C,gBAAAA,KAAK,GAAGC,IAAI,CAACE,IAAL,CAAUH,KAAV,CAAR,CAVqF,CAYrF;AACA;AACA;AACA;;AACA,oBAAII,YAAJ;;AACA,oBAAIJ,KAAK,GAAG,UAAZ,EAAwB;AACpB,sBAAMK,gBAAgB,GAAGJ,IAAI,CAACK,GAAL,CAASL,IAAI,CAACE,IAAL,CAAUH,KAAK,GAAG,CAAlB,CAAT,EAA+B,UAA/B,CAAzB;AACAI,kBAAAA,YAAY,GAAGzC,UAAU,CACrB;AAAA,2BAAM,MAAI,CAAC8B,wBAAL,CAA8BH,QAA9B,CAAN;AAAA,mBADqB,EAErBe,gBAFqB,CAAzB;AAIH,iBAND,MAMO;AACHD,kBAAAA,YAAY,GAAGzC,UAAU,CAAC,YAAM;AAC5B;AACA,wBAAIkC,IAAJ,EAAU;AACN,sBAAA,MAAI,CAACpC,cAAL,WAA2B6B,QAA3B;AACH,qBAFD,MAEO;AACH;AACA,sBAAA,MAAI,CAAC7B,cAAL,CAAoBqB,GAApB,CAAwBQ,QAAxB,EAAkC,CAAC,MAAI,CAAC5B,cAAN,EAAsB,MAAI,CAACc,IAA3B,EAAiCqB,IAAjC,CAAlC;AACH,qBAP2B,CAS5B;;;AACAnB,oBAAAA,QAAQ,CAAC6B,IAAT,CAAc,MAAd,EAV4B,CAY5B;;AACA,wBAAI,CAACV,IAAL,EAAW;AACP,sBAAA,MAAI,CAACJ,wBAAL,CAA8BH,QAA9B;AACH;AACJ,mBAhBwB,EAgBtBU,KAhBsB,CAAzB;AAiBH,iBAzCoF,CA2CrF;;;AACA,qBAAKvC,cAAL,CAAoBqB,GAApB,CAAwBQ,QAAxB,EAAkC,CAACc,YAAD,EAAeI,GAAf,EAAoBX,IAApB,CAAlC;AACH;AACJ;AACJ;AACJ;AACJ;AAED;AACJ;AACA;;;;6BACWrB,I,EAAcE,Q,EAAqC;AACtD;AACA,YAAI+B,KAAK,CAACjC,IAAD,CAAL,IAAeA,IAAI,KAAK,CAACpB,QAAzB,IAAqCoB,IAAI,KAAKpB,QAAlD,EAA4D;AACxD,gBAAM,IAAI8B,KAAJ,CAAU,+CAAV,CAAN;AACH;;AAED,YAAMI,QAAQ,GAAG,CAACd,IAAD,EAAOE,QAAP,CAAjB;;AACA,aAAKjB,cAAL,CAAoBqB,GAApB,CAAwBQ,QAAxB,EAAkC,CAAC,KAAK5B,cAAN,EAAsB8C,GAAtB,EAA2B,IAA3B,CAAlC;;AACA,aAAKf,wBAAL,CAA8BH,QAA9B,EARsD,CAUtD;;;AACA,eAAO,IAAP;AACH;AAED;AACJ;AACA;;;;+BACad,I,EAAcE,Q,EAAqC;AACxD;AACA,YAAI+B,KAAK,CAACjC,IAAD,CAAL,IAAeA,IAAI,KAAK,CAACpB,QAAzB,IAAqCoB,IAAI,KAAKpB,QAAlD,EAA4D;AACxD,gBAAM,IAAI8B,KAAJ,CAAU,iDAAV,CAAN;AACH;;AAED,YAAMI,QAAQ,GAAG,CAACd,IAAD,EAAOE,QAAP,CAAjB;;AACA,aAAKjB,cAAL,CAAoBqB,GAApB,CAAwBQ,QAAxB,EAAkC,CAAC,KAAK5B,cAAN,EAAsB8C,GAAtB,EAA2B,KAA3B,CAAlC;;AACA,aAAKf,wBAAL,CAA8BH,QAA9B,EARwD,CAUxD;;;AACA,eAAO,IAAP;AACH;AAED;AACJ;AACA;;;;+BACad,I,EAAcE,Q,EAAqC;AACxD;AACA,YAAIgC,UAAU,GAAG,KAAjB,CAFwD,CAIxD;;AAJwD,oDAKjC,KAAKjD,cAAL,CAAoB+B,IAApB,EALiC;AAAA;;AAAA;AAKxD,iEAAmD;AAAA,gBAAxCF,QAAwC;;AAAA,4CACNA,QADM;AAAA,gBACxCqB,YADwC;AAAA,gBAC1BC,gBAD0B;;AAE/C,gBAAID,YAAY,KAAKnC,IAAjB,IAAyBoC,gBAAgB,KAAKlC,QAAlD,EAA4D;AACxD;AACA,kBAAMgB,YAAY,GAAG,KAAKjC,cAAL,CAAoBmB,GAApB,CAAwBU,QAAxB,CAArB;;AACA,kBAAII,YAAJ,EAAkB;AACdI,gBAAAA,YAAY,CAACJ,YAAY,CAAC,CAAD,CAAb,CAAZ;AACH,eALuD,CAOxD;;;AACA,mBAAKjC,cAAL,WAA2B6B,QAA3B,EARwD,CAUxD;;;AACAoB,cAAAA,UAAU,GAAG,IAAb;AACH;AACJ;AApBuD;AAAA;AAAA;AAAA;AAAA;;AAsBxD,YAAI,CAACA,UAAL,EAAiB;AACb;AACA,gBAAM,IAAIxB,KAAJ,CAAU,yBAAV,CAAN;AACH,SAzBuD,CA2BxD;;;AACA,eAAO,IAAP;AACH,O,CAED;;AACA;AACJ;AACA;;;;0BACuB;AACf,YAAIa,WAAW,GAAG,KAAKhD,aAAvB,CADe,CAGf;;AACA,YAAI,KAAKG,QAAT,EAAmB;AACf;AACA6C,UAAAA,WAAW,IAAI,KAAK9C,KAAL,IAAc,KAAKT,IAAL,KAAc,KAAKQ,YAAjC,CAAf;AACH,SAPc,CASf;;;AACA,YAAI,KAAKM,KAAL,IAAe,KAAKH,QAAL,GAAgB,CAACC,QAAjB,IAA6B,KAAKC,QAAL,GAAgBD,QAAhE,EAA2E;AACvE;AACA2C,UAAAA,WAAW,GAAG,CAAC,CAACA,WAAW,GAAG,KAAK5C,QAApB,KAAiC,KAAKE,QAAL,GAAgB,KAAKF,QAAtD,KAAmE,KAAKE,QAAL,GAAgB,KAAKF,QAAxF,CAAD,KAAuG,KAAKE,QAAL,GAAgB,KAAKF,QAA5H,IAAwI,KAAKA,QAA3J;AACH,SAHD,MAGO;AACH;AACA4C,UAAAA,WAAW,GAAGE,IAAI,CAACK,GAAL,CAASL,IAAI,CAACY,GAAL,CAAS,KAAK1D,QAAd,EAAwB4C,WAAxB,CAAT,EAA+C,KAAK1C,QAApD,CAAd;AACH;;AAED,eAAO0C,WAAP;AACH;AAED;AACJ;AACA;;AAiCI;;AACA;AACJ;AACA;wBACavB,I,EAAoB;AACzB;AACA,YAAIiC,KAAK,CAACjC,IAAD,CAAL,IAAeA,IAAI,KAAK,CAACpB,QAAzB,IAAqCoB,IAAI,KAAKpB,QAAlD,EAA4D;AACxD,gBAAM,IAAI8B,KAAJ,CAAU,sCAAV,CAAN;AACH,SAJwB,CAMzB;AACA;;;AACA,YAAMa,WAAW,GAAG,KAAKvB,IAAzB;;AACA,YACI,EACI,CAAC,KAAKtB,QAAN,IACA,KAAKD,KAAL,KAAe,GADf,IAEA,CAAC,KAAKK,KAAN,KACI,KAAKL,KAAL,GAAa,CAAb,IAAkB8C,WAAW,KAAK,KAAK5C,QAAvC,IACA,KAAKF,KAAL,GAAa,CAAb,IAAkB8C,WAAW,KAAK,KAAK1C,QAF3C,CAHJ,KAOKmB,IAAI,KAAKuB,WARlB,EASE;AACE;AACA,eAAKhD,aAAL,GAAqBkD,IAAI,CAACK,GAAL,CAASL,IAAI,CAACY,GAAL,CAAS,KAAK1D,QAAd,EAAwBqB,IAAxB,CAAT,EAAwC,KAAKnB,QAA7C,CAArB;AACA,eAAKL,YAAL,GAAoB,KAAKR,IAAL,EAApB,CAHF,CAKE;;AACA,eAAK8B,yBAAL,GANF,CAQE;;;AACA,eAAKC,OAAL,CAAa,SAAb;AACH;AACJ;AAED;AACJ;AACA;;;;0BArE2B;AACnB,eAAO,KAAKrB,QAAZ;AACH;AAED;AACJ;AACA;;wBAgEgB4D,O,EAAwB;AAChC;AACA,YAAIA,OAAJ,EAAa;AACT,eAAKC,KAAL;AACH,SAFD,MAEO;AACH,eAAKC,IAAL;AACH;AACJ;AAED;AACJ;AACA;;;;0BA1EuB;AACf,eAAO,KAAK/D,KAAZ;AACH;AAED;AACJ;AACA;;wBAqEagE,I,EAAoB;AACzB;AACA,YAAIR,KAAK,CAACQ,IAAD,CAAL,IAAeA,IAAI,KAAK,CAAC7D,QAAzB,IAAqC6D,IAAI,KAAK7D,QAAlD,EAA4D;AACxD,gBAAM,IAAI8B,KAAJ,CAAU,sCAAV,CAAN;AACH,SAJwB,CAMzB;;;AACA,YAAI+B,IAAI,KAAK,KAAKhE,KAAlB,EAAyB;AACrB;AACA,cAAI,KAAKC,QAAT,EAAmB;AACf,iBAAKH,aAAL,GAAqB,KAAKyB,IAA1B;AACA,iBAAKxB,YAAL,GAAoB,KAAKR,IAAL,EAApB;AACH,WALoB,CAOrB;;;AACA,eAAKS,KAAL,GAAagE,IAAb,CARqB,CAUrB;;AACA,eAAK3C,yBAAL,GAXqB,CAarB;;;AACA,eAAKC,OAAL,CAAa,SAAb;AACH;AACJ;AAED;AACJ;AACA;;;;0BA/F0B;AAClB,eAAO,KAAKpB,QAAZ;AACH;AAED;AACJ;AACA;;wBA0FgB+D,O,EAAuB;AAC/B;AACA,YAAIA,OAAO,GAAG,KAAK7D,QAAf,IAA2BoD,KAAK,CAACS,OAAD,CAAhC,IAA6CA,OAAO,KAAK9D,QAA7D,EAAuE;AACnE,gBAAM,IAAI8B,KAAJ,CAAU,kCAAV,CAAN;AACH,SAJ8B,CAM/B;;;AACA,YAAIgC,OAAO,KAAK,KAAK/D,QAArB,EAA+B;AAC3B;AACA,cAAMgE,YAAY,GAAG,KAAK3C,IAA1B,CAF2B,CAI3B;;AACA,eAAKrB,QAAL,GAAgB+D,OAAhB,CAL2B,CAO3B;;AACA,eAAKnE,aAAL,GAAqBkD,IAAI,CAACK,GAAL,CAASL,IAAI,CAACY,GAAL,CAAS,KAAK1D,QAAd,EAAwBgE,YAAxB,CAAT,EAAgD,KAAK9D,QAArD,CAArB;AACA,eAAKL,YAAL,GAAoB,KAAKR,IAAL,EAApB,CAT2B,CAW3B;;AACA,eAAK8B,yBAAL,GAZ2B,CAc3B;;;AACA,eAAKC,OAAL,CAAa,YAAb;AACH;AACJ;AAED;AACJ;AACA;;;;0BArH0B;AAClB,eAAO,KAAKlB,QAAZ;AACH;AAED;AACJ;AACA;;wBAgHgB+D,O,EAAuB;AAC/B;AACA,YAAIA,OAAO,GAAG,KAAKjE,QAAf,IAA2BsD,KAAK,CAACW,OAAD,CAAhC,IAA6CA,OAAO,KAAK,CAAChE,QAA9D,EAAwE;AACpE,gBAAM,IAAI8B,KAAJ,CAAU,kCAAV,CAAN;AACH,SAJ8B,CAM/B;;;AACA,YAAIkC,OAAO,KAAK,KAAK/D,QAArB,EAA+B;AAC3B;AACA,cAAM8D,YAAY,GAAG,KAAK3C,IAA1B,CAF2B,CAI3B;;AACA,eAAKnB,QAAL,GAAgB+D,OAAhB,CAL2B,CAO3B;;AACA,eAAKrE,aAAL,GAAqBkD,IAAI,CAACK,GAAL,CAASL,IAAI,CAACY,GAAL,CAAS,KAAK1D,QAAd,EAAwBgE,YAAxB,CAAT,EAAgD,KAAK9D,QAArD,CAArB;AACA,eAAKL,YAAL,GAAoB,KAAKR,IAAL,EAApB,CAT2B,CAW3B;;AACA,eAAK8B,yBAAL,GAZ2B,CAc3B;;;AACA,eAAKC,OAAL,CAAa,YAAb;AACH;AACJ;AAED;AACJ;AACA;;;;0BA3IwB;AAChB,eAAO,KAAKjB,KAAZ;AACH,O;wBA0IQ+D,I,EAAqB;AAC1B;AACA,YAAIA,IAAI,KAAK,KAAK/D,KAAlB,EAAyB;AACrB;AACA,eAAKP,aAAL,GAAqB,KAAKyB,IAA1B;AACA,eAAKxB,YAAL,GAAoB,KAAKR,IAAL,EAApB,CAHqB,CAKrB;;AACA,eAAKc,KAAL,GAAa+D,IAAb,CANqB,CAQrB;;AACA,eAAK/C,yBAAL,GATqB,CAWrB;;;AACA,eAAKC,OAAL,CAAa,SAAb;AACH;AACJ","sourcesContent":["// @flow\n/// <reference types=\"./virtual-clock.d.ts\" />\n\n/**\n * A configurable virtual clock for tracking time.\n *\n * @author DaniÃ«l van de Giessen\n * @see https://virtual-clock.js.org/\n */\nexport default class VirtualClock {\n    declare _now: () => number;\n    declare _previousTime: number;\n    declare _previousNow: number;\n    declare _rate: number;\n    declare _running: boolean;\n    declare _minimum: number;\n    declare _maximum: number;\n    declare _loop: boolean;\n    declare _eventListeners: Map<string, (() => mixed)[]>;\n    declare _timeListeners: Map<[number, () => mixed], [TimeoutID, number, boolean]>;\n    declare _nullTimeoutID: TimeoutID;\n\n    /**\n     * Constructs a stopped clock with default settings.\n     */\n    constructor(): void {\n        // Determine method for retrieving now\n        this._now =\n            (typeof performance !== 'undefined' && /*global performance */ performance.now.bind(performance)) ||\n            (typeof process !== 'undefined' && /*global process */ process.hrtime && ((): number => {\n                const now: [number, number] = process.hrtime();\n                return now[0] * 1e3 + now[1] / 1e6;\n            })) ||\n            Date.now;\n\n        // Current state\n        this._previousTime = 0;\n        this._previousNow = this._now();\n\n        // Flow of time configuration\n        this._rate = 1.0;\n        this._running = false;\n\n        // Minimum / maximum / looping configuration\n        this._minimum = -Infinity;\n        this._maximum = Infinity;\n        this._loop = false;\n\n        // Event and time listeners\n        this._eventListeners = new Map();\n        this._timeListeners = new Map();\n\n        // Create unique TimeoutID to track non-scheduled timers\n        this._nullTimeoutID = setTimeout(() => {}, 0);\n\n        // Make private properties non-enumerable\n        for (const prop in this) {\n            if (prop.startsWith('_')) {\n                Object.defineProperty(this, prop, { enumerable: false });\n            }\n        }\n\n        // Bind methods to this object\n        for (const prop of Object.getOwnPropertyNames(VirtualClock.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(VirtualClock.prototype, prop);\n            if (descriptor && 'value' in descriptor && typeof descriptor.value === 'function') {\n                Object.defineProperty(this, prop, { value: descriptor.value.bind(this) });\n            }\n        }\n    }\n\n    // Methods\n    /**\n     * Starts running the clock. Does nothing when clock was already running.\n     */\n    start(): VirtualClock {\n        // Start running the time if we werent running\n        if (!this._running) {\n            this._previousNow = this._now();\n            this._running = true;\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('start');\n            this.trigger('setrunning');\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Stops running the clock. Does nothing when clock was not running.\n     */\n    stop(): VirtualClock {\n        // Stops running the time if we were running\n        if (this._running) {\n            this._previousTime = this.time;\n            this._running = false;\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('stop');\n            this.trigger('setrunning');\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Attaches an event listener.\n     *\n     * Supported events: start, stop, settime, setrunning, setrate, setminimum, setmaximum, setloop\n     */\n    on(event: string, callback: () => mixed): VirtualClock {\n        // Add the listener\n        const listeners = this._eventListeners.get(event);\n        if (listeners) {\n            listeners.push(callback);\n        } else {\n            this._eventListeners.set(event, [callback]);\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Detaches a previously attached event listener.\n     */\n    off(event: string, callback: () => mixed): VirtualClock {\n        // Find the listener\n        const listeners = this._eventListeners.get(event);\n        if (listeners) {\n            const i = listeners.indexOf(callback);\n            if (i >= 0) {\n                // Remove the listener\n                listeners.splice(i, 1);\n\n                // Method chaining\n                return this;\n            }\n        }\n\n        // When not found, throw an error\n        throw new Error('Event listener not found');\n    }\n\n    /**\n     * Triggers an attached event listener.\n     */\n    trigger(event: string, ...args: mixed[]): VirtualClock {\n        const listeners = this._eventListeners.get(event);\n        if (listeners) {\n            listeners.slice(0).forEach(listener => {\n                listener.apply(this, args);\n            });\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Private method for recalculating all registered time listeners.\n     */\n    _recalculateTimeListeners(): void {\n        for (const listener of this._timeListeners.keys()) {\n            this._recalculateTimeListener(listener);\n        }\n    }\n\n    /**\n     * Private method for recalculating a specific registered time listener.\n     */\n    _recalculateTimeListener(listener: [number, () => mixed]): void {\n        // Check if the listener is still registered\n        const listenerData = this._timeListeners.get(listener);\n        if (listenerData) {\n            const [time, callback] = listener;\n            const [timeoutID, lastCalled, once] = listenerData;\n\n            // Clear any open timeouts\n            clearTimeout(timeoutID);\n\n            // Only add timeouts if we're running and the time is reachable\n            if (this._running && this._rate !== 0 && time >= this._minimum && time <= this._maximum) {\n                // Get current time\n                const currentTime = this.time;\n\n                // Did we already run at this time?\n                if (currentTime === lastCalled) {\n                    // Is is possible to wait?\n                    if (this._loop || (currentTime !== this._minimum && currentTime !== this._maximum)) {\n                        // Wait until the time has changed enough to prevent racing and then retry\n                        this._timeListeners.set(listener, [setTimeout(() => {\n                            this._recalculateTimeListener(listener);\n                        }, 1), lastCalled, once]);\n                    }\n                } else {\n                    // Clock time until the listener should be triggered\n                    let until;\n\n                    // Initial calculation depends on which way time is moving\n                    if (this._rate > 0) {\n                        until = time - currentTime;\n                    } else {\n                        until = currentTime - time;\n                    }\n\n                    // If the time is going to be reached\n                    if (until >= 0 || (this._loop && this._minimum > -Infinity && this._maximum < Infinity)) {\n                        // Add time when looping\n                        if (until < 0) {\n                            until += this._maximum - this._minimum;\n                        }\n\n                        // Factor in the rate\n                        until *= 1 / Math.abs(this._rate);\n\n                        // Ceil the value, otherwise setTimeout may floor it and run before it is supposed to\n                        until = Math.ceil(until);\n\n                        // Workaround: many common JavaScript engines internally use a 32-bit signed integer\n                        // to save the `delay` parameter of `setTimeout`. Integer overflows may cause the\n                        // callback to be executed prematurely, thus we work around this by instead scheduling\n                        // a recalculation before this overflow value is reached.\n                        let newTimeoutID;\n                        if (until > 0x7fffffff) {\n                            const untilRecalculate = Math.min(Math.ceil(until / 2), 0x7fffffff);\n                            newTimeoutID = setTimeout(\n                                () => this._recalculateTimeListener(listener),\n                                untilRecalculate\n                            );\n                        } else {\n                            newTimeoutID = setTimeout(() => {\n                                // Should we self-destruct\n                                if (once) {\n                                    this._timeListeners.delete(listener);\n                                } else {\n                                    // Save time of call\n                                    this._timeListeners.set(listener, [this._nullTimeoutID, this.time, once]);\n                                }\n\n                                // Call the callback\n                                callback.call(this);\n\n                                // Recalculate the time listener\n                                if (!once) {\n                                    this._recalculateTimeListener(listener);\n                                }\n                            }, until);\n                        }\n\n                        // Save recalculated time listener details\n                        this._timeListeners.set(listener, [newTimeoutID, NaN, once]);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Attaches a time listener which fires once after the specified clock time has passed.\n     */\n    onceAt(time: number, callback: () => mixed): VirtualClock {\n        // Do not allow attaching to an invalid time value\n        if (isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Time passed to onceAt must be a finite number');\n        }\n\n        const listener = [time, callback];\n        this._timeListeners.set(listener, [this._nullTimeoutID, NaN, true]);\n        this._recalculateTimeListener(listener);\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Attaches a time listener which fires every time the specified clock time has passed.\n     */\n    alwaysAt(time: number, callback: () => mixed): VirtualClock {\n        // Do not allow attaching to an invalid time value\n        if (isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Time passed to alwaysAt must be a finite number');\n        }\n\n        const listener = [time, callback];\n        this._timeListeners.set(listener, [this._nullTimeoutID, NaN, false]);\n        this._recalculateTimeListener(listener);\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Detaches a previously attached time listener. If multiple listeners match, all are removed.\n     */\n    removeAt(time: number, callback: () => mixed): VirtualClock {\n        // Track whether we removed anything\n        let hasRemoved = false;\n\n        // Loop over all listeners\n        for (const listener of this._timeListeners.keys()) {\n            const [listenerTime, listenerCallback] = listener;\n            if (listenerTime === time && listenerCallback === callback) {\n                // Cancel the timeout\n                const listenerData = this._timeListeners.get(listener);\n                if (listenerData) {\n                    clearTimeout(listenerData[0]);\n                }\n\n                // Remove the listener\n                this._timeListeners.delete(listener);\n\n                // We have removed at least one listener\n                hasRemoved = true;\n            }\n        }\n\n        if (!hasRemoved) {\n            // When not found, throw an error\n            throw new Error('Time listener not found');\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    // Getters\n    /**\n     * The current clock time.\n     */\n    get time(): number {\n        let currentTime = this._previousTime;\n\n        // If running, the time is has changed since the previous time so we recalculate it\n        if (this._running) {\n            // Calculate current time based on passed time\n            currentTime += this._rate * (this._now() - this._previousNow);\n        }\n\n        // Can we loop (loop enabled + a non-zero non-finite maximum)\n        if (this._loop && (this._minimum > -Infinity && this._maximum < Infinity)) {\n            // Calculate using modulo, adjusting for the minimum\n            currentTime = ((currentTime - this._minimum) % (this._maximum - this._minimum) + (this._maximum - this._minimum)) % (this._maximum - this._minimum) + this._minimum;\n        } else {\n            // No looping means we just limit our output between minimum and maximum\n            currentTime = Math.min(Math.max(this._minimum, currentTime), this._maximum);\n        }\n\n        return currentTime;\n    }\n\n    /**\n     * Whether the clock is currently running.\n     */\n    get running(): boolean {\n        return this._running;\n    }\n\n    /**\n     * The current rate (relative to real time) the clock runs at.\n     */\n    get rate(): number {\n        return this._rate;\n    }\n\n    /**\n     * The minimum limit for time on the clock.\n     */\n    get minimum(): number {\n        return this._minimum;\n    }\n\n    /**\n     * The maximum limit for time on the clock.\n     */\n    get maximum(): number {\n        return this._maximum;\n    }\n\n    /**\n     * Whether the clock will loop around after reaching the maximum.\n     */\n    get loop(): boolean {\n        return this._loop;\n    }\n\n    // Setters\n    /**\n     * Sets the current clock time.\n     */\n    set time(time: number): void {\n        // Do not allow setting an invalid value\n        if (isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Can only set time to a finite number');\n        }\n\n        // Only act if the time is different\n        // Note: If time is changing, it is always assumed to be different\n        const currentTime = this.time;\n        if (\n            !(\n                !this._running ||\n                this._rate === 0.0 ||\n                !this._loop && (\n                    this._rate < 0 && currentTime === this._minimum ||\n                    this._rate > 0 && currentTime === this._maximum\n                )\n            ) || time !== currentTime\n        ) {\n            // Recalibrate by setting both correct time and now\n            this._previousTime = Math.min(Math.max(this._minimum, time), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('settime');\n        }\n    }\n\n    /**\n     * Starts or stops running the clock.\n     */\n    set running(running: boolean): void {\n        // Changing running state just calls start() or stop()\n        if (running) {\n            this.start();\n        } else {\n            this.stop();\n        }\n    }\n\n    /**\n     * Sets the rate (relative to real time) at which the clock runs.\n     */\n    set rate(rate: number): void {\n        // Do not allow setting an invalid value\n        if (isNaN(rate) || rate === -Infinity || rate === Infinity) {\n            throw new Error('Can only set rate to a finite number');\n        }\n\n        // Only act if the rate is different\n        if (rate !== this._rate) {\n            // Recalibration is only needed when we're running\n            if (this._running) {\n                this._previousTime = this.time;\n                this._previousNow = this._now();\n            }\n\n            // Set rate\n            this._rate = rate;\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setrate');\n        }\n    }\n\n    /**\n     * Sets minimum limit for time on the clock.\n     */\n    set minimum(minimum: number): void {\n        // Do not allow setting an invalid value\n        if (minimum > this._maximum || isNaN(minimum) || minimum === Infinity) {\n            throw new Error('Cannot set minimum above maximum');\n        }\n\n        // Only act if the minimum is different\n        if (minimum !== this._minimum) {\n            // First get the calculated time, calculated using the old minimum\n            const previousTime = this.time;\n\n            // Change the minimum\n            this._minimum = minimum;\n\n            // Recalibrate the time using the previous value and the new minimum\n            this._previousTime = Math.min(Math.max(this._minimum, previousTime), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setminimum');\n        }\n    }\n\n    /**\n     * Sets maximum limit for time on the clock.\n     */\n    set maximum(maximum: number): void {\n        // Do not allow setting an invalid value\n        if (maximum < this._minimum || isNaN(maximum) || maximum === -Infinity) {\n            throw new Error('Cannot set maximum below minimum');\n        }\n\n        // Only act if the maximum is different\n        if (maximum !== this._maximum) {\n            // First get the calculated time, calculated using the old maximum\n            const previousTime = this.time;\n\n            // Change the maximum\n            this._maximum = maximum;\n\n            // Recalibrate the time using the previous value and the new maximum\n            this._previousTime = Math.min(Math.max(this._minimum, previousTime), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setmaximum');\n        }\n    }\n\n    /**\n     * Sets whether the clock loops around after reaching the maximum.\n     */\n    set loop(loop: boolean): void {\n        // Only act if looping is different\n        if (loop !== this._loop) {\n            // Recalibrate\n            this._previousTime = this.time;\n            this._previousNow = this._now();\n\n            // Set looping\n            this._loop = loop;\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setloop');\n        }\n    }\n}\n"],"file":"virtual-clock.js"}